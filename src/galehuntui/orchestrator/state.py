"""Run state management for pipeline execution.

This module provides the RunStateManager class for tracking and managing
the state of pipeline runs, including step progress, findings, and artifacts.
"""

import asyncio
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Callable, Optional, TYPE_CHECKING
from uuid import uuid4

if TYPE_CHECKING:
    from galehuntui.storage.database import Database

from galehuntui.core.config import get_runs_dir
from galehuntui.core.audit import AuditLogger
from galehuntui.core.constants import AuditEventType, EngagementMode, PipelineStage, StepStatus
from galehuntui.core.models import (
    Finding,
    PipelineStep,
    RunConfig,
    RunMetadata,
    RunState,
    Severity,
)


@dataclass
class StageResult:
    """Result from a completed pipeline stage.
    
    Attributes:
        stage: The pipeline stage that was executed
        status: Final status of the stage
        output_data: Output data (subdomains, URLs, findings, etc.)
        output_path: Path to raw output file
        findings: List of findings generated by this stage
        duration: Execution duration in seconds
        error: Error message if stage failed
    """
    stage: PipelineStage
    status: StepStatus
    output_data: list[str] = field(default_factory=list)
    output_path: Optional[Path] = None
    findings: list[Finding] = field(default_factory=list)
    duration: float = 0.0
    error: Optional[str] = None
    
    @property
    def success(self) -> bool:
        """Check if stage completed successfully."""
        return self.status == StepStatus.COMPLETED


class RunStateManager:
    """Manages the state of a pipeline run.
    
    Tracks step progress, stores intermediate results, and manages
    the flow of data between pipeline stages.
    
    Attributes:
        run_id: Unique identifier for this run
        config: Run configuration
        metadata: Run metadata with progress tracking
    """
    
    def __init__(
        self,
        config: RunConfig,
        *,
        run_id: Optional[str] = None,
        base_dir: Optional[Path] = None,
        db: Optional["Database"] = None,
    ) -> None:
        """Initialize run state manager.
        
        Args:
            config: Run configuration
            run_id: Optional run ID (generated if not provided)
            base_dir: Base directory for run artifacts
            db: Optional database for step persistence
        """
        self.run_id = run_id or str(uuid4())
        self.config = config
        self.db = db
        
        # Set up directories
        if base_dir is None:
            base_dir = get_runs_dir()
        
        self.run_dir = base_dir / self.run_id
        self.artifacts_dir = self.run_dir / "artifacts"
        self.evidence_dir = self.run_dir / "evidence"
        self.reports_dir = self.run_dir / "reports"
        
        # Initialize metadata
        self.metadata = RunMetadata(
            id=self.run_id,
            target=config.target,
            profile=config.profile,
            engagement_mode=config.engagement_mode,
            state=RunState.PENDING,
            created_at=datetime.now(),
            run_dir=self.run_dir,
            artifacts_dir=self.artifacts_dir,
            evidence_dir=self.evidence_dir,
            reports_dir=self.reports_dir,
        )
        
        # Stage tracking
        self._steps: dict[str, PipelineStep] = {}
        self._stage_results: dict[PipelineStage, StageResult] = {}
        self._findings: list[Finding] = []
        
        # State change callbacks
        self._state_callbacks: list[Callable[[RunState], None]] = []
        self._step_callbacks: list[Callable[[PipelineStep], None]] = []
        
        # Lock for thread-safe state updates
        self._lock = asyncio.Lock()
        
        # Audit logging
        self.audit_logger: Optional[AuditLogger] = None
    
    async def initialize(self) -> None:
        """Initialize run directories and state.
        
        Creates required directories and sets up initial state.
        """
        async with self._lock:
            # Create directories
            self.run_dir.mkdir(parents=True, exist_ok=True)
            self.artifacts_dir.mkdir(parents=True, exist_ok=True)
            self.evidence_dir.mkdir(parents=True, exist_ok=True)
            self.reports_dir.mkdir(parents=True, exist_ok=True)
            
            # Create tool-specific artifact directories
            for stage in PipelineStage:
                stage_dir = self.artifacts_dir / stage.value
                stage_dir.mkdir(parents=True, exist_ok=True)
            
            # Initialize audit logger
            self.audit_logger = AuditLogger(
                run_id=self.run_id,
                audit_dir=self.run_dir,
            )
    
    async def start_run(self) -> None:
        """Mark run as started.
        
        Persists run metadata to database to enable step tracking and resume.
        """
        async with self._lock:
            self.metadata.state = RunState.RUNNING
            self.metadata.started_at = datetime.now()
            
            # Persist run metadata BEFORE any steps are saved (FK constraint)
            if self.db is not None:
                self.db.save_run(self.metadata)
            
            await self._notify_state_change(RunState.RUNNING)
            
            # Log audit event
            if self.audit_logger:
                self.audit_logger.log_event(
                    AuditEventType.RUN_START,
                    {
                        "target": self.config.target,
                        "profile": self.config.profile,
                        "mode": self.config.engagement_mode.value,
                    },
                )
    
    async def complete_run(self) -> None:
        """Mark run as completed."""
        async with self._lock:
            self.metadata.state = RunState.COMPLETED
            self.metadata.completed_at = datetime.now()
            
            if self.db is not None:
                self.db.save_run(self.metadata)
            
            await self._notify_state_change(RunState.COMPLETED)
            
            # Log audit event
            if self.audit_logger:
                duration = None
                if self.metadata.started_at and self.metadata.completed_at:
                    duration = (
                        self.metadata.completed_at - self.metadata.started_at
                    ).total_seconds()
                
                self.audit_logger.log_event(
                    AuditEventType.RUN_FINISH,
                    {
                        "status": "completed",
                        "total_findings": self.metadata.total_findings,
                        "duration": duration,
                    },
                )
    
    async def fail_run(self, error: Optional[str] = None) -> None:
        """Mark run as failed.
        
        Args:
            error: Optional error message
        """
        async with self._lock:
            self.metadata.state = RunState.FAILED
            self.metadata.completed_at = datetime.now()
            
            if self.db is not None:
                self.db.save_run(self.metadata)
            
            await self._notify_state_change(RunState.FAILED)
            
            # Log audit event
            if self.audit_logger:
                self.audit_logger.log_event(
                    AuditEventType.RUN_FINISH,
                    {
                        "status": "failed",
                        "error": error,
                    },
                )
    
    async def cancel_run(self) -> None:
        """Mark run as cancelled."""
        async with self._lock:
            self.metadata.state = RunState.CANCELLED
            self.metadata.completed_at = datetime.now()
            
            if self.db is not None:
                self.db.save_run(self.metadata)
            
            await self._notify_state_change(RunState.CANCELLED)
    
    async def pause_run(self) -> None:
        """Pause the run."""
        async with self._lock:
            if self.metadata.state == RunState.RUNNING:
                self.metadata.state = RunState.PAUSED
                await self._notify_state_change(RunState.PAUSED)
    
    async def resume_run(self) -> None:
        """Resume a paused run."""
        async with self._lock:
            if self.metadata.state == RunState.PAUSED:
                self.metadata.state = RunState.RUNNING
                await self._notify_state_change(RunState.RUNNING)
    
    def register_steps(self, step_names: list[str]) -> None:
        """Register pipeline steps to track.
        
        Args:
            step_names: List of step names in execution order
        """
        self.metadata.total_steps = len(step_names)
        
        for name in step_names:
            self._steps[name] = PipelineStep(
                name=name,
                status=StepStatus.PENDING,
            )
    
    async def start_step(self, step_name: str) -> None:
        """Mark a step as started.
        
        Args:
            step_name: Name of the step to start
        """
        async with self._lock:
            if step_name not in self._steps:
                self._steps[step_name] = PipelineStep(
                    name=step_name,
                    status=StepStatus.PENDING,
                )
            
            step = self._steps[step_name]
            step.status = StepStatus.RUNNING
            step.started_at = datetime.now()
            
            await self._notify_step_change(step)
    
    async def complete_step(
        self,
        step_name: str,
        *,
        output_path: Optional[Path] = None,
        findings_count: int = 0,
        exit_code: int = 0,
    ) -> None:
        """Mark a step as completed.
        
        Args:
            step_name: Name of the step
            output_path: Path to output file
            findings_count: Number of findings from this step
            exit_code: Tool exit code
        """
        async with self._lock:
            if step_name not in self._steps:
                return
            
            step = self._steps[step_name]
            step.status = StepStatus.COMPLETED
            step.completed_at = datetime.now()
            step.output_path = output_path
            step.findings_count = findings_count
            step.exit_code = exit_code
            
            if step.started_at:
                step.duration = (step.completed_at - step.started_at).total_seconds()
            
            self.metadata.completed_steps += 1
            
            if self.db is not None:
                self.db.save_step(self.run_id, step)
            
            await self._notify_step_change(step)
    
    async def fail_step(
        self,
        step_name: str,
        error: str,
        *,
        exit_code: int = 1,
    ) -> None:
        """Mark a step as failed.
        
        Args:
            step_name: Name of the step
            error: Error message
            exit_code: Tool exit code
        """
        async with self._lock:
            if step_name not in self._steps:
                return
            
            step = self._steps[step_name]
            step.status = StepStatus.FAILED
            step.completed_at = datetime.now()
            step.error_message = error
            step.exit_code = exit_code
            
            if step.started_at:
                step.duration = (step.completed_at - step.started_at).total_seconds()
            
            self.metadata.failed_steps += 1
            
            if self.db is not None:
                self.db.save_step(self.run_id, step)
            
            await self._notify_step_change(step)
    
    async def skip_step(self, step_name: str, reason: str = "") -> None:
        """Mark a step as skipped.
        
        Args:
            step_name: Name of the step
            reason: Reason for skipping
        """
        async with self._lock:
            if step_name not in self._steps:
                return
            
            step = self._steps[step_name]
            step.status = StepStatus.SKIPPED
            step.completed_at = datetime.now()
            step.error_message = reason or "Skipped"
            
            await self._notify_step_change(step)
    
    async def store_stage_result(
        self,
        stage: PipelineStage,
        result: StageResult,
    ) -> None:
        """Store result from a completed stage.
        
        Args:
            stage: Pipeline stage
            result: Stage result with output data
        """
        async with self._lock:
            self._stage_results[stage] = result
            
            # Add findings to global list and persist to database
            for finding in result.findings:
                finding.run_id = self.run_id
                self._findings.append(finding)
                
                # Persist finding to database
                if self.db:
                    try:
                        self.db.save_finding(finding)
                    except Exception:
                        pass  # Don't fail pipeline on DB error
            
            # Update finding counts
            self.metadata.total_findings = len(self._findings)
            self._update_findings_by_severity()
    
    def get_stage_result(self, stage: PipelineStage) -> Optional[StageResult]:
        """Get result from a previous stage.
        
        Args:
            stage: Pipeline stage to get result for
            
        Returns:
            StageResult if stage has completed, None otherwise
        """
        return self._stage_results.get(stage)
    
    def get_stage_output(self, stage: PipelineStage) -> list[str]:
        """Get output data from a previous stage.
        
        Convenience method for getting stage output data for use
        as input to subsequent stages.
        
        Args:
            stage: Pipeline stage to get output from
            
        Returns:
            List of output strings (subdomains, URLs, etc.)
        """
        result = self._stage_results.get(stage)
        if result is None:
            return []
        return result.output_data
    
    def get_step(self, step_name: str) -> Optional[PipelineStep]:
        """Get step by name.
        
        Args:
            step_name: Step name
            
        Returns:
            PipelineStep if found, None otherwise
        """
        return self._steps.get(step_name)
    
    def get_all_steps(self) -> list[PipelineStep]:
        """Get all pipeline steps.
        
        Returns:
            List of all pipeline steps in order
        """
        return list(self._steps.values())
    
    def get_all_findings(self) -> list[Finding]:
        """Get all findings from the run.
        
        Returns:
            List of all findings
        """
        return self._findings.copy()
    
    def get_artifact_path(self, stage: PipelineStage, filename: str) -> Path:
        """Get path for storing an artifact.
        
        Args:
            stage: Pipeline stage
            filename: Artifact filename
            
        Returns:
            Full path for the artifact
        """
        return self.artifacts_dir / stage.value / filename
    
    def get_evidence_path(self, finding_id: str, filename: str) -> Path:
        """Get path for storing evidence.
        
        Args:
            finding_id: Finding ID
            filename: Evidence filename
            
        Returns:
            Full path for the evidence file
        """
        finding_dir = self.evidence_dir / finding_id
        finding_dir.mkdir(parents=True, exist_ok=True)
        return finding_dir / filename
    
    def get_audit_logger(self) -> Optional[AuditLogger]:
        """Get audit logger for this run.
        
        Returns:
            AuditLogger instance if initialized, None otherwise.
        """
        return self.audit_logger
    
    def on_state_change(self, callback: Callable[[RunState], None]) -> None:
        """Register callback for state changes.
        
        Args:
            callback: Function to call when state changes
        """
        self._state_callbacks.append(callback)
    
    def on_step_change(self, callback: Callable[[PipelineStep], None]) -> None:
        """Register callback for step changes.
        
        Args:
            callback: Function to call when step status changes
        """
        self._step_callbacks.append(callback)
    
    async def _notify_state_change(self, state: RunState) -> None:
        """Notify registered callbacks of state change."""
        for callback in self._state_callbacks:
            try:
                if asyncio.iscoroutinefunction(callback):
                    await callback(state)
                else:
                    callback(state)
            except Exception:
                # Don't let callback errors break state management
                pass
    
    async def _notify_step_change(self, step: PipelineStep) -> None:
        """Notify registered callbacks of step change."""
        for callback in self._step_callbacks:
            try:
                if asyncio.iscoroutinefunction(callback):
                    await callback(step)
                else:
                    callback(step)
            except Exception:
                # Don't let callback errors break state management
                pass
    
    def _update_findings_by_severity(self) -> None:
        """Update findings count by severity."""
        counts: dict[str, int] = {}
        for finding in self._findings:
            severity = finding.severity.value
            counts[severity] = counts.get(severity, 0) + 1
        self.metadata.findings_by_severity = counts
    
    def to_dict(self) -> dict:
        """Serialize state to dictionary.
        
        Returns:
            Dictionary representation of run state
        """
        return {
            "run_id": self.run_id,
            "target": self.config.target,
            "profile": self.config.profile,
            "engagement_mode": self.config.engagement_mode.value,
            "state": self.metadata.state.value,
            "created_at": self.metadata.created_at.isoformat(),
            "started_at": self.metadata.started_at.isoformat() if self.metadata.started_at else None,
            "completed_at": self.metadata.completed_at.isoformat() if self.metadata.completed_at else None,
            "total_steps": self.metadata.total_steps,
            "completed_steps": self.metadata.completed_steps,
            "failed_steps": self.metadata.failed_steps,
            "total_findings": self.metadata.total_findings,
            "findings_by_severity": self.metadata.findings_by_severity,
            "steps": [
                {
                    "name": step.name,
                    "status": step.status.value,
                    "duration": step.duration,
                    "findings_count": step.findings_count,
                    "error": step.error_message,
                }
                for step in self._steps.values()
            ],
        }
    
    @classmethod
    async def resume(
        cls,
        run_id: str,
        db: "Database",
        config: RunConfig,
        *,
        base_dir: Optional[Path] = None,
    ) -> "RunStateManager":
        run_meta = db.get_run(run_id)
        if run_meta is None:
            raise ValueError(f"Run not found: {run_id}")
        
        steps = db.get_steps(run_id)
        
        manager = cls(config, run_id=run_id, base_dir=base_dir, db=db)
        manager.metadata = run_meta
        manager._steps = {s.name: s for s in steps}
        
        manager.run_dir = run_meta.run_dir
        manager.artifacts_dir = run_meta.artifacts_dir
        manager.evidence_dir = run_meta.evidence_dir
        manager.reports_dir = run_meta.reports_dir
        
        return manager
    
    def get_completed_step_names(self) -> set[str]:
        return {
            name for name, step in self._steps.items()
            if step.status == StepStatus.COMPLETED
        }
